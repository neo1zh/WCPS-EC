import sys
import socket
import time
import re
from datetime import datetime
import numpy as np


round_counter = 1
theta_ref = 0
thetaini = 0
uini = 0
delta_t = 0.02
yh_last = 0
yh = 1
kp = 100
kd = 13
kdd = 4
ki = 100
kii =10
compu_latency = []

class P3IDController:
    def __init__(self, kp, ki,kii, kd, kdd, delta_t):
        self.kp = kp         # Proportional gain
        self.ki = ki   
        self.kii = kii      # Integral gain
        self.kd = kd         # Derivative gain
        self.kdd = kdd       # Second derivative gain
        self.delta_t = delta_t
        self.theta_error_last = 0
        self.theta_error_before_last = 0
        self.integral = 0
        self.u_last = 0
    
    def reset(self):
        self.theta_error_last = 0
        self.theta_error_before_last = 0
        self.integral = 0
        self.u_last = 0

    def update(self, theta_error):
        # Calculate the difference of the errors for the derivative terms
        d_error = theta_error - self.theta_error_last
        dd_error = theta_error - 2 * self.theta_error_last + self.theta_error_before_last
        
        # Integral error calculation
        self.integral += theta_error

        # PIDDD calculation
        uout_increment = (
            self.kp * d_error +                               # Proportional term
            self.ki * theta_error * self.delta_t +         # Integral term
            self.kii * (theta_error + self.theta_error_last) * self.delta_t * self.delta_t+ 
            self.kd * d_error / self.delta_t +                # First derivative term
            self.kdd * dd_error / (self.delta_t * self.delta_t)   # Second derivative term
        )
        uout = self.u_last+uout_increment
        # Update last errors
        self.theta_error_before_last = self.theta_error_last
        self.theta_error_last = theta_error
        self.u_last = uout
        return uout
    
    def update_noise(self,theta_error):
        # Calculate the difference of the errors for the derivative terms
        d_error = theta_error - self.theta_error_last
        dd_error = theta_error - 2 * self.theta_error_last + self.theta_error_before_last
        
        # Integral error calculation
        self.integral += theta_error

        # PIDDD calculation
        uout_increment = (
            self.kp * d_error +                               # Proportional term
            self.ki * theta_error * self.delta_t +         # Integral term
            self.kii * (theta_error + self.theta_error_last) * self.delta_t * self.delta_t+ 
            self.kd * d_error / self.delta_t +                # First derivative term
            self.kdd * dd_error / (self.delta_t * self.delta_t)   # Second derivative term
        )
        uout = self.u_last+uout_increment
        noise = np.random.normal(0, 1)
        uout += noise
        # Update last errors
        self.theta_error_before_last = self.theta_error_last
        self.theta_error_last = theta_error
        self.u_last = uout
        return uout
        

p3id_controller = P3IDController(kp,ki,kii, kd, kdd, delta_t)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('10.181.212.213', 8000)
print('starting up on %s port %s' % server_address, file=sys.stderr)
sock.bind(server_address)
sock.listen(1)
while True:
    connection, client_address = sock.accept()
    print('Connection from:', client_address, file=sys.stderr)
    try:
        while True:
            data = connection.recv(80)
            if data:
                data = data.decode("utf-8")
                t = time.time()
                print(data)
                print(round_counter)
                timeT = datetime.now().strftime('%Y,%m,%d,%H,%M,%S.%f')
                print("data=", data)
                data_split = [float(x.strip()) for x in re.compile('-*\w+.\w+').findall(data.strip())]
                if data_split[0] != 10000:
                    theta_ref = data_split[0]
                    theta = data_split[1]
                    theta_error = data_split[2]
                    yh_last = yh
                    yh = data_split[3]
                    sensor_seq = data_split[4]
                    if yh_last != yh:
                        round_counter = 1
                        yh_last = yh
                        p3id_controller.reset()
                    if round_counter == 1:
                        uout = uini + kp * theta_error 
                    else:
                        uout = p3id_controller.update_noise(theta_error)
                    print("Uout generated by python code on server:", uout)
                    connection.send(('% 3.4f,% 3.4f' % (uout, sensor_seq)).encode("utf-8"))
                    round_counter = round_counter + 1
                    elapsed = time.time() - t
                    print("Computational latency:", elapsed)
                    compu_latency.extend([elapsed])
                    if sensor_seq > 1198:
                        print("Computational latency list", compu_latency)
            else:
                break
    finally:
        connection.close()
